<!-- 
Copyright 2006 Sun Microsystems, Inc. All rights reserved.

Sun Microsystems, Inc. has intellectual property rights relating to technology
embodied in the product that is described in this document. In particular, and
without limitation, these intellectual property rights may include one or more
of the U.S. patents listed at http://www.sun.com/patents and one or more
additional patents or pending patent applications in the U.S. and in other
countries.
U.S. Government Rights - Commercial software. Government users are subject to
the Sun Microsystems, Inc. standard license agreement and applicable provisions
of the FAR and its supplements.

Use is subject to license terms.

This distribution may include materials developed by third parties.Sun, Sun
Microsystems, phoneME and Java are trademarks or registered trademarks of Sun
Microsystems, Inc. in the U.S. and other countries.


Copyright 2006 Sun Microsystems, Inc. Tous droits réservés.

Sun Microsystems, Inc. détient les droits de propriété intellectuels relatifs à
la technologie incorporée dans le produit qui est décrit dans ce document. En
particulier, et ce sans limitation, ces droits de propriété intellectuelle
peuvent inclure un ou plus des brevets américains listés à l'adresse
http://www.sun.com/patents et un ou les brevets supplémentaires ou les
applications de brevet en attente aux Etats - Unis et dans les autres pays.

L'utilisation est soumise aux termes du contrat de licence.

Cette distribution peut comprendre des composants développés par des tierces
parties.

Sun, Sun Microsystems, phoneME et Java sont des marques de fabrique ou des
marques déposées de Sun Microsystems, Inc. aux Etats-Unis et dans d'autres pays.
-->
  <body>
  This package consists of classes that provides the core abstractions for
  a content store. A content store uses a <Code>JUMPStore</code> to persist the
  content store data.

  <p>
  The following sample code shows, how a store can be implemented on a 
  filesystem. Every node that does not contain <code>JUMPData</code> is
  represented as a directory in the filesystem and every data node is 
  represented in a single file say <b>data.properties</b>. Each line in the
  data.properties file contains the following information.
  <b>data-name,data-type,data-value</b>
  <pre>

  public class FileStoreImpl implements JUMPStore {

     public void createDataNode(String uri, JUMPData jumpData) {

        // get the full path of the file that holds the data for the
        // uri passed.
        File file = uriToDataFile(uri);
        // the data name is the last component of the URI.
        String dataName = getDataName(uri);
        String marshalledData = createMarshalledData(dataName, jumpData);
        OutputStream stream = createOutputStream(file);
        stream.writeString(marshalled);
      
        // The impl might create an instance of JUMPNode containing the jumpData
        // eagerly here, or delay until it is requested by getNode(String uri) 
        // call below.
     }

     public void createNode(String uri) {
        File file = uriToFile(uri);
        file.mkdirs();
     }                  

     public JUMPNode getNode(String uri) {
        // getNode(String) needs to return what the createDataNode() above store
        // if the uri parameter represents a data node.
   
        if (!isDataFile(uri)) {

            // This URI represents non-leaf node.
            // .... then do something to create a JUMPNode representing a List,
            // and return it.

        }  else {    
   
            File file = urlToDataFile(uri);
      
            String name = getDataName(uri);
            InputStream stream = createInputStream(file);
            String marshalledData = stream.readString();
      
            JUMPData data = createUnmarshalledData(marshalledData);
      
            JUMPNode node = createJUMPNode(uri, name, data);
      
            return node;
        }
     }

     public void deleteNode(String uri) {
        File file = uriToFile(uri);
        file.delete();
     }

     public void updateNode(String uri, JUMPData jumpData) {
        // check if the node represented by the uri exists and is data.
        if (!isDataFile(uri) || !exists(uri) ) {
           throw new java.io.IOException("Update failed"); 
        }
 
        // delete the old node and create a node with the new data.
        deleteNode(uri);
        createDataNode(uri, jumpData);
     }
   
     private String createMarshalledData(String dataname, JUMPData data) {
        // Create a representation of JUMPData's content to be written out to the file.
        // This method does not have to process anything in JUMPData data, but merely to
        // come up with a String representation of the JUMPData content that works the
        // opposite way of createUnmarshalledData.  The returned type, String, is also
        // just for the implementation example, and can also be in any other format.
     }

     private JUMPData createUnmarshalledData(String marshalledData) {
        // Creates a JUMPData out of the "marshalledData" representation.
        // This method should just do the opposite of createMarshalledData(JUMPData).
     }
  } 
  </pre>
  The following sample code shows how a concrete content store can be implemented
  by extending the <Code>JUMPContentStore</Code>. The object that the sample 
  stores in the content store is <code>Application</code> which consists of
  a title and a iconPath. <Code>AppRepository</Code> has methods to get
  the <Code>Application</Code> objects.
  
  <pre>
  public class Application {
     
     public String getTitle() {
        return title;
     }
     
     public String getIconPath() {
        return iconPath;
     }
  }
  
  public class AppRepository extends JUMPContentStore {
      private static final String ROOT_URI = "./Apps";
      private Class storeClass = JUMPFileStore.class;
      
      
      protected JUMPStore getStore() {
         return JUMPExecutive.getInstance().getModule(this.storeClass);
      }
      
      public Application getApplication(String name) {
          Application app = new Application();
          // get access to the store in a read-only mode
          JUMPStoreHandle storeHandle = openStore(false);
          
          JUMPNode.Data appNode = (JUMPNode.Data)
            storeHandle.getNode(ROOT_URI+"/"+name+"/title");
          app.setTitle(appNode.getString());
          appNode = (JUMPNode.Data)
            storeHandle.getNode(ROOT_URI+"/"+name+"/iconPath");
          app.setIconPath(appNode.getString());
          
          // indicate that we do not need the store any more
          closeStore(storeHandle);
          return app;
      }
  }
  
  </pre>
  </body>
